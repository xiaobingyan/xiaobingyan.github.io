{"meta":{"title":"Zoe.Xiao's Blog","subtitle":"缓解焦虑","description":"缓解焦虑","author":"zoe.xiao","url":"https://xiaobingyan.github.io"},"pages":[{"title":"关于","date":"2018-03-03T07:10:30.000Z","updated":"2018-03-03T07:11:29.764Z","comments":false,"path":"about/index.html","permalink":"https://xiaobingyan.github.io/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-03-03T07:09:06.000Z","updated":"2018-03-03T07:09:39.955Z","comments":false,"path":"tags/index.html","permalink":"https://xiaobingyan.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-03-03T07:04:52.000Z","updated":"2018-03-03T07:08:13.765Z","comments":false,"path":"categories/index.html","permalink":"https://xiaobingyan.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"pyspark学习笔记","slug":"pyspark_note","date":"2018-03-03T07:20:05.000Z","updated":"2018-03-03T07:39:47.752Z","comments":true,"path":"2018/03/03/pyspark_note/","link":"","permalink":"https://xiaobingyan.github.io/2018/03/03/pyspark_note/","excerpt":"目前：ubuntu 14.04，spark2.2.0-bin-hadoop2.7，pycharm，jupyter notebook，IPython。 主要参考以下来源自己做的梳理。PySpark API DocSpark 2.2.0 RDD中文手册","text":"目前：ubuntu 14.04，spark2.2.0-bin-hadoop2.7，pycharm，jupyter notebook，IPython。 主要参考以下来源自己做的梳理。PySpark API DocSpark 2.2.0 RDD中文手册 要想在Python shell中使用Spark，直接运行./bin/pyspark命令即可，如果配置了pyspark的环境变量，则直接运行pyspark命令即可。与Scala shell类似， Python下的SparkContext对象可以通过Python变量sc来调用 主要结构介绍Spark目前主要提供了以下6大功能。 Spark Core: RDD及其算子。 Spark-SQL: DataFrame与SQL。 Spark ML(MLlib): 机器学习框架。 Spark Streaming: 实时计算框架。 Spark GraphX: 图计算框架。 PySpark(SparkR): Spark之上的Python与R框架。 RDDresilient distributed dataset 完全弹性分布式的，因为有replicate机制所以部分数据丢失可以重建，高容错，在集群当中若几台节点故障一样可以正常运行，高scalability，横向扩展直接多增加集群节点可以直接提高性能.。Spark主要通过sparkcontext.textfile 加载文件变成RDD，然后通过transformation构建一个新的RDD，通过action将RDD存储到外部节点. RDD对象是不可变的。一旦对象被创建，它们的值就无法再变化。 RDD有一头delay 加载，换句话说类似Dask的 lazy evaluation，只有用得到的时候才加载数据，如果加载存储所有的中间过程会浪费空间，这样会影响spark的性能. 一旦spark看到整个变换链，他可以计算仅需要结果数据，如果下面的函数不需要数据那么也不会再加载，转换RDD也是lazy的只有actions的时候才会调用它们。 Spark分为driver和executor，driver提交作业，executor是application早worknode上的进程，运行task，driver对应为sparkcontext。 RDD有两种操作算子： Transformation（转换）：Transformation属于延迟计算，当一个RDD转换成另一个RDD时并没有立即进行转换，仅仅是记住了数据集的逻辑操作（如map()、reduceByKey()）。总是返回对一个RDD对象的引用。 Ation（执行）：触发Spark作业的运行，真正触发转换算子的计算（take()，reduce()，saveAsTextFile()，collect()）。 Spark的RDD操作有transformation、action。Transformation对RDD进行依赖包装，RDD所对应的依赖都进行DAG的构建并保存，在worknode挂掉之后除了通过备份恢复还可以通过元数据对其保存的依赖再计算一次得到。当作业提交也就是调用runJob时，spark会根据RDD构建DAG图，提交给DAGScheduler，这个DAGScheduler是在SparkContext创建时一同初始化的，他会对作业进行调度处理。当依赖图构建好以后，从action开始进行解析，每一个操作作为一个task，每遇到shuffle就切割成为一个taskSet，并把数据输出到磁盘，如果不是shuffle数据还在内存中存储。就这样再往前推进，直到没有算子，然后运行从前面开始，如果没有action的算子在这里不会执行，直到遇到action为止才开始运行，这就形成了spark的懒加载，taskset提交给TaskSheduler生成TaskSetManager并且提交给Executor运行，运行结束后反馈给DAGScheduler完成一个taskSet，之后再提交下一个，当TaskSet运行失败时就返回DAGScheduler并重新再次创建。一个job里面可能有多个TaskSet，一个application可能包含多个job。 Spark streaming通过对kafka数据读取，将Stream数据分成小的时间片段（几秒），以类似batch批处理的方式来处理这一部分小数据，每个时间片生成一个RDD，有高效的容错性，对小批量数据可以兼容批量实时数据处理的逻辑算法，用一些历史数据和实时数据联合进行分析，比如分类算法等。也可以对小批量的stream进行mapreduce、join等操作，而保证其实时性。针对数据流时间要求不到毫秒级的工程性问题都可以。 Spark Streaming也有一个StreamingContext，其核心是DStream，是通过以组时间序列上的连续RDD来组成的，包含一个有Time作为key、RDD作为value的结构体，每一个RDD都包含特定时间间隔的数据流，可以通过persist将其持久化。在接受不断的数据流后，在blockGenerator中维护一个队列，将流数据放到队列中，等处理时间间隔到来后将其中的所有数据合并成为一个RDD(这一间隔中的数据)。其作业提交和spark相似，只不过在提交时拿到DStream内部的RDD并产生Job提交，RDD在action触发之后，将job提交给jobManager中的JobQueue，又jobScheduler调度，JobScheduler将job提交到spark的job调度器，然后将job转换成为大量的任务分发给spark集群执行。Job从outputStream中生成的，然后触发反向回溯执行DStreamDAG。在流数据处理的过程中，一般节点失效的处理比离线数据要复杂。Spark streamin在1.3之后可以周期性的将DStream写入HDFS，同时将offset也进行存储，避免写到zk。一旦主节点失效，会通过checkpoint的方式读取之前的数据。当worknode节点失效，如果HDFS或文件作为输入源那Spark会根据依赖关系重新计算数据，如果是基于Kafka、Flume等网络数据源spark会将手机的数据源在集群中的不同节点进行备份，一旦有一个工作节点失效，系统能够根据另一份还存在的数据重新计算，但是如果接受节点失效会丢失一部分数据，同时接受线程会在其他的节点上重新启动并接受数据。 Graphx主要用于图的计算。核心算法有PageRank、SVD奇异矩阵、TriangleConut等。 Spark SQL是Spark新推出的交互式大数据SQL技术。把sql语句翻译成Spark上的RDD操作可以支持Hive、Json等类型的数据。 SparkContext类和SparkConf类具体pyspark.SparkContext包含的方法 SparkContext 是管理Spark里的集群（cluster）和协调集群运行进程的对象，功能的主入口。SparkContext与集群的manager相连。Manager负责管理运行具体运算的执行者。1class pyspark.SparkContext(master=None, appName=None, sparkHome=None, pyFiles=None, environment=None, batchSize=0, serializer=PickleSerializer(), conf=None, gateway=None, jsc=None, profiler_cls=&lt;class &apos;pyspark.profiler.BasicProfiler&apos;&gt;) SparkConf用于初始化 12conf = SparkConf().setAppName(appName).setMaster(master)sc = SparkContext(conf=conf) appName 参数是一个在集群 UI 上展示应用程序的名称。 master 是一个 Spark, Mesos 或 YARN 的 cluster URL，或者指定为在 local mode（本地模式）中运行的 “local” 字符串。 Spark程序的编写都是从SparkContext（或用Java编写时的JavaSparkContext）开始的。SparkContext的初始化需要一个SparkConf对象，后者包含了Spark集群配置的各种参数（比如主节点的URL），用于将各种Spark参数设置为键值对。。初始化后，我们便可用SparkContext对象所包含的各种方法来创建和操作分布式数据集和共享变量。Spark shell（在Scala和Python下可以，但不支持Java）能自动完成上述初始化。我们可以通过如下方式调SparkContext的简单构造函数，以默认的参数值来创建4线程的SparkContext对象，并将其相应的任务命名为Test SparkAPP。：1val sc = new SparkContext(&quot;local[4]&quot;, &quot;Test Spark App&quot;) 广播变量（broadcast）和累加器（accumulator）通常情况下，一个传递给 Spark 操作（例如 map 或 reduce）的函数 func 是在远程的集群节点上执行的。该函数 func 在多个节点执行过程中使用的变量，是同一个变量的多个副本。这些变量的以副本的方式拷贝到每个机器上，并且各个远程机器上变量的更新并不会传播回 driver program（驱动程序）。通用且支持 read-write（读-写） 的共享变量在任务间是不能胜任的。所以，Spark 提供了两种特定类型的共享变量 : broadcast variables（广播变量）和 accumulators（累加器）。 广播变量（broadcast）为只读变量，由运行SparkContext的驱动程序创建后发送给会参与计算的节点，可以被工作节点访问。对那些需要各个工作节点高效访问相同数据的应用场景十分有用。 Spark 的 action（动作）操作是通过一系列的 stage（阶段）进行执行的，这些 stage（阶段）是通过分布式的 “shuffle” 操作进行拆分的。Spark 会自动广播出每个 stage（阶段）内任务所需要的公共数据。这种情况下广播的数据使用序列化的形式进行缓存，并在每个任务运行前进行反序列化。这也就意味着，只有在跨越多个 stage（阶段）的多个任务会使用相同的数据，或者在使用反序列化形式的数据特别重要的情况下，使用广播变量会有比较好的效果。 广播变量通过在一个变量v 上调用 SparkContext.broadcast(v) 方法来进行创建。广播变量是 v 的一个 wrapper（包装器），可以通过调用 value 方法来访问它的值。代码示例如下: 12345&gt;&gt;&gt; broadcastVar = sc.broadcast([1, 2, 3])&lt;pyspark.broadcast.Broadcast object at 0x102789f10&gt;&gt;&gt;&gt; broadcastVar.value[1, 2, 3] 在创建广播变量之后，在集群上执行的所有的函数中，应该使用该广播变量代替原来的 v 值，所以节点上的 v 最多分发一次。另外，对象 v 在广播后不应该再被修改，以保证分发到所有的节点上的广播变量具有同样的值（例如，如果以后该变量会被运到一个新的节点）。 累加器（accumulator）也是一种被广播到工作节点的变量，是一个仅可以执行 “added”（添加）的变量，但是支持的累加操作有一定的限制。这种累加得保证在全局范围内累加起来的值能被正确地并行计算以及返回驱动程序。每一个工作节点只能访问和操作自己本地的累加器，全局累加器则只允许驱动程序访问。 累加器可以用于实现 counter（ 计数，类似在 MapReduce 中那样）或者 sums（求和）。原生 Spark 支持数值型的累加器，并且程序员可以添加新的支持类型。 作为一个用户，您可以创建 accumulators（累加器）并且重命名。, 一个命名的 accumulator 累加器（在这个例子中是 counter）将显示在 web UI 中，用于修改该累加器的阶段。 Spark 在 “Tasks” 任务表中显示由任务修改的每个累加器的值. python下通过sc调用SparkContext。 通过调用·SparkContext.accumulator(v)从初始值v创建一个累加器。 然后可以使用add方法或+=`运算符将在群集上运行的任务添加到其中。 但是，他们看不到它的值。 只有驱动程序可以使用value方法读取累加器的值。 下面的代码显示了一个累加器用于将数组的元素相加：12345678910&gt;&gt;&gt; accum = sc.accumulator(0)&gt;&gt;&gt; accumAccumulator&lt;id=0, value=0&gt;&gt;&gt;&gt; sc.parallelize([1, 2, 3, 4]).foreach(lambda x: accum.add(x))...10/09/29 18:41:08 INFO SparkContext: Tasks finished in 0.317106 s&gt;&gt;&gt; accum.value10 虽然此代码使用Int类型的累加器的内置支持，但程序员也可以通过对AccumulatorParam进行子类化来创建自己的类型。 AccumulatorParam接口有两种方法：zero为您的数据类型提供“零值”，addInPlace用于将两个值相加在一起。 例如，假设我们有一个代表数学向量的Vector类，我们可以写：12345678910class VectorAccumulatorParam(AccumulatorParam): def zero(self, initialValue): return Vector.zeros(initialValue.size) def addInPlace(self, v1, v2): v1 += v2 return v1# Then, create an Accumulator of this type:vecAccum = sc.accumulator(Vector(...), VectorAccumulatorParam()) 累加器的更新只发生在 action 操作中，Spark 保证每个任务只更新累加器一次，例如，重启任务不会更新值。在 transformations（转换）中， 用户需要注意的是，如果 task（任务）或 job stages（阶段）重新执行，每个任务的更新操作可能会执行多次。 累加器不会改变 Spark lazy evaluation（懒加载）的模式。如果累加器在 RDD 中的一个操作中进行更新，它们的值仅被更新一次，RDD 被作为 action 的一部分来计算。因此，在一个像 map() 这样的 transformation（转换）时，累加器的更新并没有执行。下面的代码片段证明了这个特性:123456accum = sc.accumulator(0)def g(x): accum.add(x) return f(x)data.map(g)# Here, accum is still 0 because no actions have caused the `map` to be computed. parallelize和分区（partitions）parallelize(c, numSlices = None)通过在驱动程序中现有的迭代或集合上调用SparkContext的parallelize方法来创建分发本地Python集合以形成RDD。if the input represents a range for performance，则建议使用xrange。 集合的元素被复制以形成可以并行操作的分布式数据集。例如：1234&gt;&gt;&gt; sc.parallelize([0, 2, 3, 4, 6], 5).glom().collect()[[0], [2], [3], [4], [6]]&gt;&gt;&gt; sc.parallelize(xrange(0, 6, 2), 5).glom().collect()[[], [0], [], [2], [4]] 并行集合中一个很重要参数是 partitions（分区）的数量，它可用来切割 dataset（数据集）。Spark 将在集群中的每一个分区上运行一个任务。通常您希望群集中的每一个 CPU 计算 2-4 个分区。一般情况下，Spark 会尝试根据您的群集情况来自动的设置的分区的数量。当然，您也可以将分区数作为第二个参数传递到 parallelize方法中 (e.g. sc.parallelize(data, 10))来手动的设置它。注意: 代码中的一些地方会使用 term slices (a synonym for partitions) 以保持向后兼容。 可以使用data.partitions.size来查询一个RDD被划分的分区数。 textFiletextFile(name, minPartitions=None, use_unicode=True从HDFS，本地文件系统（在所有节点上可用）或任何Hadoop支持的文件系统URI读取文本文件，并将其作为字符串的RDD返回。 如果use_unicode为False，则字符串将保持为str（编码为utf-8），它比unicode更快更小。 （在Spark 1.2中添加）123456&gt;&gt;&gt; path = os.path.join(tempdir, &quot;sample-text.txt&quot;)&gt;&gt;&gt; with open(path, &quot;w&quot;) as testFile:... _ = testFile.write(&quot;Hello world!&quot;)&gt;&gt;&gt; textFile = sc.textFile(path)&gt;&gt;&gt; textFile.collect()[u&apos;Hello world!&apos;] wholeTextFiles(path,minPartitions = None,sue_unicode = True)从HDFS，本地文件系统（在所有节点上可用）或任何Hadoop支持的文件系统URI读取文本文件的目录。 每个文件被读取为单个记录并返回到键值对中，其中键是每个文件的路径，该值是每个文件的内容。 例如有以下文件：1234hdfs://a-hdfs-path/part-00000hdfs://a-hdfs-path/part-00001...hdfs://a-hdfs-path/part-nnnnn 使用语句rdd = sparkContext.wholeTextFiles(&#39;hdfs://a-hdfs-path&#39;)rdd中包含1234(a-hdfs-path/part-00000, its content)(a-hdfs-path/part-00001, its content)...(a-hdfs-path/part-nnnnn, its content) addFile(path,recursive=False)在每个节点上添加使用此Spark作业要下载的文件。 传递的路径可以是本地文件，HDFS（或其他Hadoop支持的文件系统）中的文件，或HTTP，HTTPS或FTP URI。 要在Spark作业中访问文件，请使用文件名L {SparkFiles.get（fileName）&lt;pyspark.files.SparkFiles.get&gt;}来查找其下载位置。class pyspark.SparkFiles：SparkFiles只包含类方法; 用户不应该创建SparkFiles实例。有以下两个方法classmethod get(filename)获取通过SparkContext.addFile()添加的文件的绝对路径。 classmethod getRootDirectory()获取包含通过SparkContext.addFile()添加的文件的根目录。 如果递归选项设置为True，则可以给出目录。 目前仅支持Hadoop支持的文件系统。1234567891011&gt;&gt;&gt; from pyspark import SparkFiles&gt;&gt;&gt; path = os.path.join(tempdir, &quot;test.txt&quot;)&gt;&gt;&gt; with open(path, &quot;w&quot;) as testFile:... _ = testFile.write(&quot;100&quot;)&gt;&gt;&gt; sc.addFile(path)&gt;&gt;&gt; def func(iterator):... with open(SparkFiles.get(&quot;test.txt&quot;)) as testFile:... fileVal = int(testFile.readline())... return [x * fileVal for x in iterator]&gt;&gt;&gt; sc.parallelize([1, 2, 3, 4]).mapPartitions(func).collect()[100, 200, 300, 400] addPyFile(path)为将来在此SparkContext上执行的所有任务添加.py或.zip依赖项。 传递的路径可以是本地文件，HDFS（或其他Hadoop支持的文件系统）中的文件，或HTTP，HTTPS或FTP URI。 pickleFile加载先前使用RDD.saveAsPickleFile方法保存的RDD。12345&gt;&gt;&gt; tmpFile = NamedTemporaryFile(delete=True)&gt;&gt;&gt; tmpFile.close()&gt;&gt;&gt; sc.parallelize(range(10)).saveAsPickleFile(tmpFile.name, 5)&gt;&gt;&gt; sorted(sc.pickleFile(tmpFile.name, 3).collect())[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] sequenceFilesequenceFile(path, keyClass=None, valueClass=None, keyConverter=None, valueConverter=None, minSplits=None, batchSize=0)从HDFS，本地文件系统（在所有节点上可用）或任何Hadoop支持的文件系统URI读取具有任意键和值的Hadoop SequenceFile可写类。 机制如下： cancelAllJobs()取消已安排或正在运行的所有作业。 cancelJobGroup(groupId)取消指定组的活动作业。 有关更多信息，请参阅SparkContext.setJobGroup。 setJobGroup将组ID分配给此线程启动的所有作业，直到组ID设置为不同的值或清除为止。 通常，应用程序中的执行单元由多个Spark操作或作业组成。 应用程序员可以使用此方法将所有这些作业分组在一起并给出组描述。 一旦设置，Spark Web UI将将这些作业与该组关联。 该应用程序可以使用SparkContext.cancelJobGroup取消此组中的所有正在运行的作业。 runJob(rdd,partitionFunc, partitions=None, allowLocal=False)在指定的分区集上执行给定的partitionFunc，将结果作为元素数组返回。 如果未指定“分区”，则将在所有分区上运行。123&gt;&gt;&gt; myRDD = sc.parallelize(range(6), 3)&gt;&gt;&gt; sc.runJob(myRDD, lambda part: [x * x for x in part])[0, 1, 4, 9, 16, 25] 123&gt;&gt;&gt; myRDD = sc.parallelize(range(6), 3)&gt;&gt;&gt; sc.runJob(myRDD, lambda part: [x * x for x in part], [0, 2], True)[0, 1, 16, 25]//[0, 1], [2, 3], [4, 5] emptyRDD()创建一个没有分区或元素的RDD。 hadoopRddhadoopRDD(inputFormatClass, keyClass, valueClass, keyConverter=None, valueConverter=None, conf=None, batchSize=0)从任意的Hadoop配置中读取具有任意键和值类的“旧”Hadoop InputFormat，该配置以Python语法传入。 这将被转换为Java中的配置。 机制与sc.sequenceFile相同。 getConf()getLocalProperty(key)获取此线程中的本地属性集，如果缺少则为null。 请参阅setLocalPropertyclassmethod getOrCreate(conf=None)获取或实例化一个SparkContext并将其注册为单例对象。 参数：conf – SparkConf (optional) startTime返回SparkContext启动时的时间 stop()关闭SparkContext。 range(start, end=None,step = 1, numSlices = None)创建一个新的包含从start到end元素的RDD，每个元素按步长增加。 可以像python的内置range()函数一样调用。 如果使用单个参数调用，则该参数被解释为end，start被设置为0。 Parameters: start – the start value end – the end value (exclusive) step – 步长(default: 1) numSlices –新RDD的分区数 Returns: An RDD of int 123456&gt;&gt;&gt; sc.range(5).collect()[0, 1, 2, 3, 4]&gt;&gt;&gt; sc.range(2, 4).collect()[2, 3]&gt;&gt;&gt; sc.range(1, 7, 2).collect()[1, 3, 5] unions(rdds)构建RDD列表的联合。 这支持使用不同序列化格式的RDD的unions()，尽管这迫使它们使用默认序列化程序进行反序列化：12345678910#os库，还记得吗？&gt;&gt;&gt; path = os.path.join(tempdir, &quot;union-text.txt&quot;)&gt;&gt;&gt; with open(path, &quot;w&quot;) as testFile:... _ = testFile.write(&quot;Hello&quot;)&gt;&gt;&gt; textFile = sc.textFile(path)&gt;&gt;&gt; textFile.collect()[u&apos;Hello&apos;]&gt;&gt;&gt; parallelized = sc.parallelize([&quot;World!&quot;])&gt;&gt;&gt; sorted(sc.union([textFile, parallelized]).collect())[u&apos;Hello&apos;, &apos;World!&apos;] RDD的优先位置（preferredLocations）RDD优先位置属性与Spark中的调度有关，返回的是RDD的每个partition所存储的位置。 操作RDD形如RDD.XXXsum()用来对所有记录的长度求和cache()将数据缓存在内存里：rddFromTextFile.cache take(n)返回RDD前n个元素 partitionBy(numPartitions, parttionFunc=…)返回用指定分区器进行分区的RDD的副本。1234&gt;&gt;&gt; pairs = sc.parallelize([1, 2, 3, 4, 2, 4, 1]).map(lambda x: (x, x))&gt;&gt;&gt; sets = pairs.partitionBy(2).glom().collect()&gt;&gt;&gt; len(set(sets[0]).intersection(set(sets[1])))0 12345678# partitionByx = sc.parallelize([(0,1),(1,2),(2,3)],2)y = x.partitionBy(numPartitions = 3, partitionFunc = lambda x: x) # only key is passed to paritionFuncprint(x.glom().collect())print(y.glom().collect())[[(0, 1)], [(1, 2), (2, 3)]][[(0, 1)], [(1, 2)], [(2, 3)]] repartition(numPartitions)返回一个正好具有numPartition分区的新RDD。Reshuffle（重新洗牌）RDD 中的数据以创建或者更多的 partitions（分区）并将每个分区中的数据尽量保持均匀. 该操作总是通过网络来 shuffles 所有的数据.可以增加或减少此RDD中的并行度。 在内部，它使用随机播放来重新分配数据。 如果您减少此RDD中的分区数，请考虑使用coalesce，这可以避免执行shuffle。1234567&gt;&gt;&gt; rdd = sc.parallelize([1,2,3,4,5,6,7], 4)&gt;&gt;&gt; sorted(rdd.glom().collect())[[1], [2, 3], [4, 5], [6, 7]]&gt;&gt;&gt; len(rdd.repartition(2).glom().collect())2&gt;&gt;&gt; len(rdd.repartition(10).glom().collect())10 repaetitionAndSortWithPartitions( …)1repaetitionAndSortWithPartitions(numPartitions=None, partitionFunc = ... , ascending = True , keyfunc = ...) 根据给定的分区器重新分区RDD，并且在每个生成的分区中，通过它们的键对记录进行排序。这比每一个分区中先调用 repartition 然后再 sorting（排序）效率更高，因为它可以将排序过程推送到 shuffle 操作的机器上进行.1234&gt;&gt;&gt; rdd = sc.parallelize([(0, 5), (3, 8), (2, 6), (0, 8), (3, 8), (1, 3)])&gt;&gt;&gt; rdd2 = rdd.repartitionAndSortWithinPartitions(2, lambda x: x % 2, 2)&gt;&gt;&gt; rdd2.glom().collect()[[(0, 5), (0, 8), (2, 6)], [(1, 3), (3, 8), (3, 8)]] coalesce(numPartitions, shuffle = False)合并分区，返回一个减少到numPartition分区的新RDD。1234&gt;&gt;&gt; sc.parallelize([1, 2, 3, 4, 5], 3).glom().collect()[[1], [2, 3], [4, 5]]&gt;&gt;&gt; sc.parallelize([1, 2, 3, 4, 5], 3).coalesce(1).glom().collect()[[1, 2, 3, 4, 5]] randomSplit(weights, seed = None)用提供的权重随机分割此RDD。参数： - 权重 ：分割权重，如果不等于1则将被归一化 - 种子 -：随机种子 返回： 拆分RDD为列表 12345678&gt;&gt;&gt; rdd = sc.parallelize(range(500), 1)&gt;&gt;&gt; rdd1, rdd2 = rdd.randomSplit([2, 3], 17)&gt;&gt;&gt; len(rdd1.collect() + rdd2.collect())500&gt;&gt;&gt; 150 &lt; rdd1.count() &lt; 250True&gt;&gt;&gt; 250 &lt; rdd2.count() &lt; 350True keyBy()通过函数 f 来创建RDD中元素的元组。1234&gt;&gt;&gt; x = sc.parallelize(range(0,3)).keyBy(lambda x: x*x)&gt;&gt;&gt; y = sc.parallelize(zip(range(0,5), range(0,5)))&gt;&gt;&gt; [(x, list(map(list, y))) for x, y in sorted(x.cogroup(y).collect())][(0, [[0], [0]]), (1, [[1], [1]]), (2, [[], [2]]), (3, [[], [3]]), (4, [[2], [4]])] keys()返回一个由每个元组的键组成的RDD。 values()使用每个元组的值返回一个RDD。123&gt;&gt;&gt; m = sc.parallelize([(1, 2), (3, 4)]).values()&gt;&gt;&gt; m.collect()[2, 4] collect()collect()是一个Spark 的 action 函数， 将整个RDD以集合的形式返回驱动程序，通常在需要将结果返回到驱动程序坐在的节点以供本地处理时使用。注意：如果在非常大的数据集上使用可能耗尽内存。 collectAsMap()将RDD中的键值对返回给主机作为字典。同样，只有在生成的数据预期较小时，才应使用此方法，因为所有数据都将加载到驱动程序的内存中。12345&gt;&gt;&gt; m = sc.parallelize([(1, 2), (3, 4)]).collectAsMap()&gt;&gt;&gt; m[1]2&gt;&gt;&gt; m[3]4 persist(storageLevel=StorageLevel(False, True, False, False, 1))设置此RDD的存储级别，以便在第一次计算后将其值跨操作持久化。 如果RDD尚未设置存储级别，则这只能用于分配新的存储级别。 如果没有指定存储级别默认值为（MEMORY_ONLY）。123&gt;&gt;&gt; rdd = sc.parallelize([&quot;b&quot;, &quot;a&quot;, &quot;c&quot;])&gt;&gt;&gt; rdd.persist().is_cachedTrue cache()使用默认存储级别（MEMORY_ONLY）保持此RDD。 count()action函数。返回此RDD中的元素数。12&gt;&gt;&gt; sc.parallelize([2, 3, 4]).count()3 countByKey计算每个键的元素数量，并将结果作为字典返回到主数据。123&gt;&gt;&gt; rdd = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 1), (&quot;a&quot;, 1)])&gt;&gt;&gt; sorted(rdd.countByKey().items())[(&apos;a&apos;, 2), (&apos;b&apos;, 1)] countByValue()将此RDD中每个唯一值的计数作为（值，计数）对的字典返回。12&gt;&gt;&gt; sorted(sc.parallelize([1, 2, 1, 2, 2], 2).countByValue().items())[(1, 2), (2, 3)] ####distinct(numPartitions=None)返回一个包含此RDD中不同元素的新RDD。就是去重。12&gt;&gt;&gt; sorted(sc.parallelize([1, 1, 2, 3]).distinct().collect())[1, 2, 3] intersection(other)返回此RDD和另一个的交集，输出不包含任何重复的元素。 注意This method performs a shuffle internally.（输出无序应该是）1234&gt;&gt;&gt; rdd1 = sc.parallelize([1, 10, 2, 3, 4, 5])&gt;&gt;&gt; rdd2 = sc.parallelize([1, 6, 2, 3, 7, 8])&gt;&gt;&gt; rdd1.intersection(rdd2).collect()[1, 2, 3] union(other)返回新RDD，包含这个RDD和其它RDD的并集。123&gt;&gt;&gt; rdd = sc.parallelize([1, 1, 2, 3])&gt;&gt;&gt; rdd.union(rdd).collect()[1, 1, 2, 3, 1, 1, 2, 3] subtract(other, numPartitions=None)返回包含在自身但是不包含在 other 中的值。比较的是元素：1234&gt;&gt;&gt; x = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 4), (&quot;b&quot;, 5), (&quot;a&quot;, 3)])&gt;&gt;&gt; y = sc.parallelize([(&quot;a&quot;, 3), (&quot;c&quot;, None)])&gt;&gt;&gt; sorted(x.subtract(y).collect())[(&apos;a&apos;, 1), (&apos;b&apos;, 4), (&apos;b&apos;, 5)] subtractByKey(other, numPartitions=None)返回在自身中有而在 other 中没有匹配键对应的键值对。这里比较的是键： 1234&gt;&gt;&gt; x = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 4), (&quot;b&quot;, 5), (&quot;a&quot;, 2)])&gt;&gt;&gt; y = sc.parallelize([(&quot;a&quot;, 3), (&quot;c&quot;, None)])&gt;&gt;&gt; sorted(x.subtractByKey(y).collect())[(&apos;b&apos;, 4), (&apos;b&apos;, 5)] sum()将此RDD中的元素相加。12&gt;&gt;&gt; sc.parallelize([1.0, 2.0, 3.0]).sum()6.0 histogram(buckets)直方图根据给定的区间（buckets）计算直方图，区间右边都是开的，比如 [1, 10, 20, 50] 指的是 [1, 10) [10, 20) [20, 50]。 And on the input of 1 and 50 we would have a histogram of 1,0,1。输入的区间必须是排序好的，不包含重复项，至少有两个元素。 返回值是 a tuple of buckets and histogram.12345678910&gt;&gt;&gt; rdd = sc.parallelize(range(51))&gt;&gt;&gt; rdd.histogram(2)([0, 25, 50], [25, 26])&gt;&gt;&gt; rdd.histogram([0, 5, 25, 50])([0, 5, 25, 50], [5, 20, 26])&gt;&gt;&gt; rdd.histogram([0, 15, 30, 45, 60]) # evenly spaced buckets([0, 15, 30, 45, 60], [15, 15, 15, 6])&gt;&gt;&gt; rdd = sc.parallelize([&quot;ab&quot;, &quot;ac&quot;, &quot;b&quot;, &quot;bd&quot;, &quot;ef&quot;])&gt;&gt;&gt; rdd.histogram((&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))((&apos;a&apos;, &apos;b&apos;, &apos;c&apos;), [2, 2]) mean()计算这个RDD元素的平均值。12&gt;&gt;&gt; sc.parallelize([1, 2, 3]).mean()2.0 stdev()计算该RDD元素的标准差。12&gt;&gt;&gt; sc.parallelize([1, 2, 3]).stdev()0.816... variance()计算这个RDD中元素的方差。12&gt;&gt;&gt; sc.parallelize([1, 2, 3]).variance()0.666... stats()返回一个StatCounter object包含 mean, variance and count of the RDD’s elements in one operation. sample(withReplacement, fraction, seed=None)返回此RDD的采样子集。参数： withReplacement： 可以对元素进行多次采样（是否放回） fraction ：样本的预期大小作为without替换的RDD大小的分数：每个元素被选择的概率; fraction必须在[0，1]with替换：每个元素选择的预期次数; 分数必须&gt; = 0（采样的百分比） seed： 随机数发生器的种子 123&gt;&gt;&gt; rdd = sc.parallelize(range(100), 4)&gt;&gt;&gt; 6 &lt;= rdd.sample(False, 0.1, 81).count() &lt;= 14True 1234567891011121314# samplex = sc.parallelize(range(7))# call &apos;sample&apos; 5 timesylist = [x.sample(withReplacement=False, fraction=0.5) for i in range(5)]print(&apos;x = &apos; + str(x.collect()))for cnt, y in zip(range(len(ylist)), ylist): print(&apos;sample:&apos; + str(cnt) + &apos; y = &apos; + str(y.collect()))x = [0, 1, 2, 3, 4, 5, 6]sample:0 y = [0, 2, 5, 6]sample:1 y = [2, 6]sample:2 y = [0, 4, 5, 6]sample:3 y = [0, 2, 6]sample:4 y = [0, 3, 4] sampleByKey(withPrplacement, fractions, seed = None)返回通过键采样的该RDD的子集（通过分层采样）。 使用分数指定的不同键的可变采样率创建此RDD的样本，a key to sampling rate map.123456789&gt;&gt;&gt; fractions = &#123;&quot;a&quot;: 0.2, &quot;b&quot;: 0.1&#125;&gt;&gt;&gt; rdd = sc.parallelize(fractions.keys()).cartesian(sc.parallelize(range(0, 1000)))&gt;&gt;&gt; sample = dict(rdd.sampleByKey(False, fractions, 2).groupByKey().collect())&gt;&gt;&gt; 100 &lt; len(sample[&quot;a&quot;]) &lt; 300 and 50 &lt; len(sample[&quot;b&quot;]) &lt; 150True&gt;&gt;&gt; max(sample[&quot;a&quot;]) &lt;= 999 and min(sample[&quot;a&quot;]) &gt;= 0True&gt;&gt;&gt; max(sample[&quot;b&quot;]) &lt;= 999 and min(sample[&quot;b&quot;]) &gt;= 0True 12345678# sampleByKeyx = sc.parallelize([(&apos;A&apos;,1),(&apos;B&apos;,2),(&apos;C&apos;,3),(&apos;B&apos;,4),(&apos;A&apos;,5)])y = x.sampleByKey(withReplacement=False, fractions=&#123;&apos;A&apos;:0.5, &apos;B&apos;:1, &apos;C&apos;:0.2&#125;)print(x.collect())print(y.collect())[(&apos;A&apos;, 1), (&apos;B&apos;, 2), (&apos;C&apos;, 3), (&apos;B&apos;, 4), (&apos;A&apos;, 5)][(&apos;B&apos;, 2), (&apos;C&apos;, 3), (&apos;B&apos;, 4)] sampleStdev()计算该RDD元素的样本标准偏差（其通过除以N-1而不是N来校正标准偏差中的偏差）。12&gt;&gt;&gt; sc.parallelize([1, 2, 3]).sampleStdev()1.0 sampleVariance()计算这个RDD元素的样本方差（通过用N-1而不是N来估计方差来校正偏差）。12&gt;&gt;&gt; sc.parallelize([1, 2, 3]).sampleVariance()1.0 zipWithIndex()使用其元素索引将此RDD压缩。 排序首先基于分区索引，然后根据每个分区中的项目顺序。 因此，第一个分区中的第一个项目获取索引0，最后一个分区中的最后一个项目将收到最大的索引。 当此RDD包含多个分区时，此方法需要触发spark job。12&gt;&gt;&gt; sc.parallelize([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], 3).zipWithIndex().collect()[(&apos;a&apos;, 0), (&apos;b&apos;, 1), (&apos;c&apos;, 2), (&apos;d&apos;, 3)] zipWithUniqueId()使用生成的唯一长 ID 来zip此 RDD。 第 k 个分区中的项将得到 ID k，n + k，2 * n + k，…，其中n是分区数。 所以可能存在差距，但是这种方法不会引发spark job，这与zipWithIndex不同。12&gt;&gt;&gt; sc.parallelize([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;], 3).zipWithUniqueId().collect()[(&apos;a&apos;, 0), (&apos;b&apos;, 1), (&apos;c&apos;, 4), (&apos;d&apos;, 2), (&apos;e&apos;, 5)] sortBy(keyfunc, ascending=True, numPartitions=None)通过给定的keyfunc对此RDD进行排序。12345&gt;&gt;&gt; tmp = [(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;1&apos;, 3), (&apos;d&apos;, 4), (&apos;2&apos;, 5)]&gt;&gt;&gt; sc.parallelize(tmp).sortBy(lambda x: x[0]).collect()[(&apos;1&apos;, 3), (&apos;2&apos;, 5), (&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;d&apos;, 4)]&gt;&gt;&gt; sc.parallelize(tmp).sortBy(lambda x: x[1]).collect()[(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;1&apos;, 3), (&apos;d&apos;, 4), (&apos;2&apos;, 5)] sortByKey(ascending=True, numPartitions=None, keyfunc=…)在一个 (K, V) pair 的 dataset 上调用时，其中的 K 实现了 Ordered，返回一个按 keys 升序或降序的 (K, V) pairs 的 dataset, 由 boolean 类型的 ascending 参数来指定.1234567891011&gt;&gt;&gt; tmp = [(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;1&apos;, 3), (&apos;d&apos;, 4), (&apos;2&apos;, 5)]&gt;&gt;&gt; sc.parallelize(tmp).sortByKey().first()(&apos;1&apos;, 3)&gt;&gt;&gt; sc.parallelize(tmp).sortByKey(True, 1).collect()[(&apos;1&apos;, 3), (&apos;2&apos;, 5), (&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;d&apos;, 4)]&gt;&gt;&gt; sc.parallelize(tmp).sortByKey(True, 2).collect()[(&apos;1&apos;, 3), (&apos;2&apos;, 5), (&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;d&apos;, 4)]&gt;&gt;&gt; tmp2 = [(&apos;Mary&apos;, 1), (&apos;had&apos;, 2), (&apos;a&apos;, 3), (&apos;little&apos;, 4), (&apos;lamb&apos;, 5)]&gt;&gt;&gt; tmp2.extend([(&apos;whose&apos;, 6), (&apos;fleece&apos;, 7), (&apos;was&apos;, 8), (&apos;white&apos;, 9)])&gt;&gt;&gt; sc.parallelize(tmp2).sortByKey(True, 3, keyfunc=lambda k: k.lower()).collect()[(&apos;a&apos;, 3), (&apos;fleece&apos;, 7), (&apos;had&apos;, 2), (&apos;lamb&apos;, 5),...(&apos;white&apos;, 9), (&apos;whose&apos;, 6)] glom()一个分区的元素放在同一个list中，作为新RDD返回。123&gt;&gt;&gt; rdd = sc.parallelize([1, 2, 3, 4], 2)&gt;&gt;&gt; sorted(rdd.glom().collect())[[1, 2], [3, 4]] foreach(f)对这个RDD的所有元素应用一个函数。12&gt;&gt;&gt; def f(x): print(x)&gt;&gt;&gt; sc.parallelize([1, 2, 3, 4, 5]).foreach(f) foreachPartition(f)将函数应用于此RDD的每个分区。1234&gt;&gt;&gt; def f(iterator):... for x in iterator:... print(x)&gt;&gt;&gt; sc.parallelize([1, 2, 3, 4, 5]).foreachPartition(f) pipe(command, env=None, checkCode=False)pipe管道将pyspark的RDD对象fork给外部进程，然后再返回RDD对象。通过使用 shell 命令来将每个 RDD 的分区给 Pipe。例如，一个 Perl 或 bash 脚本。RDD 的元素会被写入进程的标准输入（stdin），并且 lines（行）输出到它的标准输出（stdout）被作为一个字符串型 RDD 的 string 返回.12345678# pipex = sc.parallelize([&apos;A&apos;, &apos;Ba&apos;, &apos;C&apos;, &apos;AD&apos;])y = x.pipe(&apos;grep -i &quot;A&quot;&apos;) # calls out to grep, may fail under Windowsprint(x.collect())print(y.collect())[&apos;A&apos;, &apos;Ba&apos;, &apos;C&apos;, &apos;AD&apos;][&apos;A&apos;, &apos;Ba&apos;, &apos;AD&apos;] cartesian(other)返回此RDD和另一个RDD的笛卡尔乘积，即所有成对元素（a，b）的RDD，其中a为自身，b为其他元素。123&gt;&gt;&gt; rdd = sc.parallelize([1, 2])&gt;&gt;&gt; sorted(rdd.cartesian(rdd).collect())[(1, 1), (1, 2), (2, 1), (2, 2)] 在数学中，两个集合X和Y的笛卡儿积（Cartesian product），又称直积，在集合论中表示为X × Y，是所有可能的有序对組成的集合，其中有序对的第一个对象是X的成员，第二个对象是Y的成员。 aggregate(zeroValue, seqOp, combOp)聚合每个分区的元素，然后对所有分区的结果，使用给定的组合函数和中性“零值”。允许函数op（t1，t2）修改t1并返回它作为其结果值，以避免对象分配; 但是，它不应该修改t2。第一个函数（seqOp）可以返回与该RDD类型不同的结果类型U。 因此，我们需要一个用于将T合并成U的操作和用于合并两个U的一个操作。123456789101112#建立各分区内的聚集函数，由初始值依次与分区内的函数做操作&gt;&gt;&gt; seqOp = (lambda x, y: (x[0] + y, x[1] + 1))#建立各分区间的组合函数，&gt;&gt;&gt; combOp = (lambda x, y: (x[0] + y[0], x[1] + y[1]))#样例1&gt;&gt;&gt; sc.parallelize([1, 2, 3, 4], 4).aggregate((0, 0), seqOp, combOp)(10, 4)&gt;&gt;&gt; sc.parallelize([]).aggregate((0, 0), seqOp, combOp)(0, 0)#样例2&gt;&gt;&gt; sc.parallelize([ 1, 2, 3, 4, 5]，3).aggregate((1,1), seqOp, combOp)(19,9） 解释样例1：分区数：40：11：22：33：4利用zerovalue(0, 0)和seqOp对各分区进行聚集：x[0] = 0, x[1] = 00：(0+1, 0+1)-&gt;(1, 1)1：(0+2, 0+1)-&gt;(2, 1)2：(0+3, 0+1)-&gt;(3, 1)3：(0+4, 0+1)-&gt;(4, 1) 利用zerovalue(0, 0)和combOp进行各分区间的聚合：(0, 0) + (1, 1) + (2, 1) + (3, 1) + (4, 1) = (10, 4) 解释样例2：分区数：30：1, 21：3, 43：5 利用zerovalue(1, 1)和seqOp对各分区进行聚集：x[0] = 1, x[1] = 10：(1+1, 1+1)=&gt;(2, 2)-&gt;x[0] = 2, x[1] = 2, y=2=&gt;(4, 3)1：(1, 1) + (3, 1) + (4, 1) = (8, 3)2：(1, 1) + (5, 1) = (6, 2) 利用zerovalue(1, 1)和combOp进行各分区间的聚合：(1, 1) + (4, 3) + (8, 3) = (19, 9) aggregateByKey使用给定的组合函数和中性“零值”来聚合每个键的值。 该函数可以返回不同于此RDD，V中的值的类型的不同的结果类型U。因此，我们需要一个操作来将V合并到一个U中，一个操作用于合并两个U，前者的操作用于 合并分区中的值，后者用于在分区之间合并值。 为了避免内存分配，这两个函数都允许修改并返回其第一个参数，而不是创建一个新的U. 在 (K, V) pairs 的 dataset 上调用时, 返回 (K, U) pairs 的 dataset，其中的 values 是针对每个 key 使用给定的 combine 函数以及一个 neutral “0” 值来进行聚合的. 允许聚合值的类型与输入值的类型不一样, 同时避免不必要的配置. 像 groupByKey 一样, reduce tasks 的数量是可以通过第二个可选的参数来配置的。 aggregateByKey 把类型为KV的RDD类型转为K U的RDD，V和U的类型可以不一样，这一点跟combineByKey是一样的，即返回的二元组值类型可以不一样 aggregateByKey 内部是通过调用combineByKey来实现的，combineByKey的createCombine函数逻辑由zeroValue这个变量实现，zeroValue 作为聚合的初始值。 1234567891011# aggregateByKeyx = sc.parallelize([(&apos;B&apos;,1),(&apos;B&apos;,2),(&apos;A&apos;,3),(&apos;A&apos;,4),(&apos;A&apos;,5)])zeroValue = [] # empty list is &apos;zero value&apos; for append operationmergeVal = (lambda aggregated, el: aggregated + [(el,el**2)])mergeComb = (lambda agg1,agg2: agg1 + agg2 )y = x.aggregateByKey(zeroValue,mergeVal,mergeComb)print(x.collect())print(y.collect())[(&apos;B&apos;, 1), (&apos;B&apos;, 2), (&apos;A&apos;, 3), (&apos;A&apos;, 4), (&apos;A&apos;, 5)][(&apos;A&apos;, [(3, 9), (4, 16), (5, 25)]), (&apos;B&apos;, [(1, 1), (2, 4)])] groupBy1groupBy(f, numPartitions=None, partitionFunc=&lt;function portable_hash at 0x7f51f1ac0668&gt;) 返回根据给定函数分好组的RDD。1234&gt;&gt;&gt; rdd = sc.parallelize([1, 1, 2, 3, 5, 8])&gt;&gt;&gt; result = rdd.groupBy(lambda x: x % 2).collect()&gt;&gt;&gt; sorted([(x, sorted(y)) for (x, y) in result])[(0, [2, 8]), (1, [1, 1, 3, 5])] groupByKey1groupByKey(numPartitions=None, partitionFunc=&lt;function portable_hash at 0x7f51f1ac0668&gt;) 将单个RDD中每个键的值分组为单个序列。在一个 (K, V) pair 的 dataset 上调用时，返回一个 (K, Iterable)。12345&gt;&gt;&gt; rdd = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 1), (&quot;a&quot;, 1)])&gt;&gt;&gt; sorted(rdd.groupByKey().mapValues(len).collect())[(&apos;a&apos;, 2), (&apos;b&apos;, 1)]&gt;&gt;&gt; sorted(rdd.groupByKey().mapValues(list).collect())[(&apos;a&apos;, [1, 1]), (&apos;b&apos;, [1])] 注意：注意如果为了在每个key上执行聚合操作（如sum或average）进行分组，则使用reduceByKey或aggregateByKey将提供更好的性能。注意：默认情况下，并行度取决于父 RDD 的分区数。可以传递一个可选的 numTasks 参数来设置不同的任务数。 cogroup(other, numPartitions=None)两个RDD元素一起分组，对于自身或其他中的每个关键字k，返回包含元组的结果RDD，该元组具有该键在自身以及其他RDD中对应的值的列表。在一个 (K, V) 和的 dataset 上调用时，返回一个 (K, (Iterable&lt;V&gt;, Iterable&lt;W&gt;)) tuples 的 dataset. 这个操作也调用了 groupWith。12345&gt;&gt;&gt; x = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 4)])&gt;&gt;&gt; y = sc.parallelize([(&quot;a&quot;, 2)])#列表推导式&gt;&gt;&gt; [(x, tuple(map(list, y))) for x, y in sorted(list(x.cogroup(y).collect()))][(&apos;a&apos;, ([1], [2])), (&apos;b&apos;, ([4], []))] groupWith(other, *others)别名为cogroup但支持多个RDD。123456&gt;&gt;&gt; w = sc.parallelize([(&quot;a&quot;, 5), (&quot;b&quot;, 6)])&gt;&gt;&gt; x = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 4)])&gt;&gt;&gt; y = sc.parallelize([(&quot;a&quot;, 2)])&gt;&gt;&gt; z = sc.parallelize([(&quot;b&quot;, 42)])&gt;&gt;&gt; [(x, tuple(map(list, y))) for x, y in sorted(list(w.groupWith(x, y, z).collect()))][(&apos;a&apos;, ([5], [1], [2], [])), (&apos;b&apos;, ([6], [4], [], [42]))] 1234567891011121314151617181920# groupWithx = sc.parallelize([(&apos;C&apos;,4),(&apos;B&apos;,(3,3)),(&apos;A&apos;,2),(&apos;A&apos;,(1,1))])y = sc.parallelize([(&apos;B&apos;,(7,7)),(&apos;A&apos;,6),(&apos;D&apos;,(5,5))])z = sc.parallelize([(&apos;D&apos;,9),(&apos;B&apos;,(8,8))])a = x.groupWith(y,z)print(x.collect())print(y.collect())print(z.collect())print(&quot;Result:&quot;)for key,val in list(a.collect()): print(key, [list(i) for i in val])[(&apos;C&apos;, 4), (&apos;B&apos;, (3, 3)), (&apos;A&apos;, 2), (&apos;A&apos;, (1, 1))][(&apos;B&apos;, (7, 7)), (&apos;A&apos;, 6), (&apos;D&apos;, (5, 5))][(&apos;D&apos;, 9), (&apos;B&apos;, (8, 8))]Result:D [[], [(5, 5)], [9]]C [[4], [], []]B [[(3, 3)], [(7, 7)], [(8, 8)]]A [[2, (1, 1)], [6], []] combineByKey1combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions=None, partitionFunc=&lt;function portable_hash at 0x7f51f1ac0668&gt;) 使用一组自定义聚合函数来组合每个键的元素。将RDD[(K, V)]转换为RDD[(K, C)] ，C是combined type。用户应该提供： createCombiner将V转换为C（例如，创建单元列表） mergeValue，将V合并为C（例如，将其添加到列表的末尾） mergeCombiners将两个C组合成一个C（例如，合并列表） 为了避免内存分配，mergeValue和mergeCombiners都允许修改并返回其第一个参数，而不是创建一个新的C.此外，用户可以控制输出RDD的分区。1234567891011121314&gt;&gt;&gt; x = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 1), (&quot;a&quot;, 2)])&gt;&gt;&gt; def to_list(a):... return [a]...&gt;&gt;&gt; def append(a, b):... a.append(b)... return a...&gt;&gt;&gt; def extend(a, b):... a.extend(b)... return a...&gt;&gt;&gt; sorted(x.combineByKey(to_list, append, extend).collect())[(&apos;a&apos;, [1, 2]), (&apos;b&apos;, [1])] join(other, numPartitions = None)相当于inner join. 对两个需要连接的RDD进行cogroup，然后对每个Key下面的list进行笛卡尔积的操作，输出两两相交两个集合作为value ，相当于sql中where a.key= b.key。每对元素将作为(k, (v1, v2))元组返回，其中( k, v1)在自身中，(k, v2)在另一个元素中。 在一个 (K, V) 和 (K, W) 类型的 dataset 上调用时，返回一个 (K, (V, W)) pairs 的 dataset，它拥有每个 key 中所有的元素对。Outer joins 可以通过 leftOuterJoin, rightOuterJoin 和 fullOuterJoin 来实现。1234&gt;&gt;&gt; x = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 4)])&gt;&gt;&gt; y = sc.parallelize([(&quot;a&quot;, 2), (&quot;a&quot;, 3)])&gt;&gt;&gt; sorted(x.join(y).collect())[(&apos;a&apos;, (1, 2)), (&apos;a&apos;, (1, 3))] fullOuterJoin(other, numPartitions = None) 实现self和other的全外联结对于每个self中的 (k, v) 元素，结果RDD中将要么包含所有 (k,(v,w)) 对，w 来自other，要么为 (k, (v, None))，如果 other中没有 k 键。类似的，如果self中没有 k 键，就是 (k,(None, w))。Hash-partitions the resulting RDD into the given number of partitions.1234&gt;&gt;&gt; x = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 4)])&gt;&gt;&gt; y = sc.parallelize([(&quot;a&quot;, 2), (&quot;c&quot;, 8)])&gt;&gt;&gt; sorted(x.fullOuterJoin(y).collect())[(&apos;a&apos;, (1, 2)), (&apos;b&apos;, (4, None)), (&apos;c&apos;, (None, 8))] 于 ANSI 标准的 SQL 列出了五种 JOIN 方式: 内连接(INNER), 全外连接(FULL OUTER), 左外连接(LEFT OUTER), 右外连接(RIGHT OUTER)和交叉连接(CROSS).外连接并不要求连接的两表的每一条记录在对方表中都一条匹配的记录。 leftOuterJoin(other, numPartitions=None)rightOuterJoinfold(zeroValue, op)聚合每个分区的元素，然后使用给定的关联函数和中性“零值”对所有分区的结果进行聚合。 允许函数op（t1，t2）修改t1并将其作为其结果值返回，以避免对象分配; 但是，它不应该修改t2。 这与Scala等功能语言中的非分布式集合实现的折叠操作有所不同。 该折叠操作可以单独应用于分区，然后将这些结果折叠成最终结果，而不是以某些定义的顺序将折叠应用于每个元素。 对于不可交换的功能，结果可能与应用于非分布式集合的折叠的结果不同。123&gt;&gt;&gt; from operator import add&gt;&gt;&gt; sc.parallelize([1, 2, 3, 4, 5]).fold(0, add)15 foldByKey使用关联函数“func”和中性“零值”合并每个键的值，该值可以添加到任意次数的结果中，并且不得更改结果（例如，0为加法，或1为乘法。）。1234&gt;&gt;&gt; rdd = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 1), (&quot;a&quot;, 1)])&gt;&gt;&gt; from operator import add&gt;&gt;&gt; sorted(rdd.foldByKey(0, add).collect())[(&apos;a&apos;, 2), (&apos;b&apos;, 1)] map(f, preservesPartitioning = False)和flatmapmap是最常用的转换操作，对RDD中的每个元素都执行一个指定的函数来产生一个新的RDD。任何原RDD中的元素在新RDD中都有且只有一个元素与之对应。而flatmap通过对这个RDD的所有元素应用一个函数，然后平坦化结果来返回一个新的RDD。所以 func 应该返回一个 Seq 而不是一个单独的 item。 Example below：12345678910#from pyspark import SparkContext, SparkConf#sc = SparkContext(&quot;local&quot;,&quot;testApp&quot;)x = sc.parallelize([1,2,3])y = x.map(lambda x : (x, x**2))z = x.flatMap(lambda x: (x, 100*x, x**2))print(x.collect())print(y.collect())print(z.collect()) out:123[1, 2, 3][(1, 1), (2, 4), (3, 9)][1, 100, 1, 2, 200, 4, 3, 300, 9] flatMapValues(f)传递键值对RDD中的每个值通过flatMap函数，而无需更改键; 这也保留了原始RDD的分区。1234&gt;&gt;&gt; x = sc.parallelize([(&quot;a&quot;, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]), (&quot;b&quot;, [&quot;p&quot;, &quot;r&quot;])])&gt;&gt;&gt; def f(x): return x&gt;&gt;&gt; x.flatMapValues(f).collect()[(&apos;a&apos;, &apos;x&apos;), (&apos;a&apos;, &apos;y&apos;), (&apos;a&apos;, &apos;z&apos;), (&apos;b&apos;, &apos;p&apos;), (&apos;b&apos;, &apos;r&apos;)] mapvalues(f)只把键值对中的值进行map，不更改键和分区。1234&gt;&gt;&gt; x = sc.parallelize([(&quot;a&quot;, [&quot;apple&quot;, &quot;banana&quot;, &quot;lemon&quot;]), (&quot;b&quot;, [&quot;grapes&quot;])])&gt;&gt;&gt; def f(x): return len(x)&gt;&gt;&gt; x.mapValues(f).collect()[(&apos;a&apos;, 3), (&apos;b&apos;, 1)] 12345678# mapValuesx = sc.parallelize([(&apos;A&apos;, (1, 2, 3)), (&apos;B&apos;, (4, 5))])y = x.mapValues(lambda x: [i**2 for i in x]) # function is applied to entire valueprint(x.collect())print(y.collect())[(&apos;A&apos;, (1, 2, 3)), (&apos;B&apos;, (4, 5))][(&apos;A&apos;, [1, 4, 9]), (&apos;B&apos;, [16, 25])] mapPartitions(f, preservesPartitioning=False)mapPartitions是map的一个变种,map的输入函数应用于RDD中的每一个元素，而mapPartition的输入函数是应用于每个分区，也就是把每个分区中的内容作为整体来处理。在一个类型为 T 的 RDD 上运行时 func 必须是 Iterator&lt;T&gt; =&gt; Iterator&lt;U&gt; 类型。12345678910# mapPartitionsx = sc.parallelize([1,2,3], 2)def f(iterator): yield sum(iterator)y = x.mapPartitions(f)# glom() flattens elements on the same partitionprint(x.glom().collect())print(y.glom().collect())[[1], [2, 3]][[1], [5]] mapPartitionsWithIndex(f, preservesPartitioning=False)通过对该RDD的每个分区应用一个函数，同时跟踪原始分区的索引来返回一个新的RDD。需要提供一个代表 partition 的 index（索引）的 interger value（整型值）作为参数的 func，所以在一个类型为 T 的 RDD 上运行时 func 必须是 (Int, Iterator&lt;T&gt;) =&gt; Iterator&lt;U&gt; 类型。1234&gt;&gt;&gt; rdd = sc.parallelize([1, 2, 3, 4], 4)&gt;&gt;&gt; def f(splitIndex, iterator): yield splitIndex&gt;&gt;&gt; rdd.mapPartitionsWithIndex(f).sum()6 1234567891011# mapPartitionsWithIndexx = sc.parallelize([1,2,3], 2)def f(partitionIndex, iterator): yield (partitionIndex,sum(iterator))y = x.mapPartitionsWithIndex(f)# glom() flattens elements on the same partitionprint(x.glom().collect())print(y.glom().collect())[[1], [2, 3]][[(0, 1)], [(1, 5)]] filter(f)返回一个仅包含满足谓词的元素的新RDD。123&gt;&gt;&gt; rdd = sc.parallelize([1, 2, 3, 4, 5])&gt;&gt;&gt; rdd.filter(lambda x: x % 2 == 0).collect()[2, 4] reduce(f)属于action。Reduce比groupby好，能用reduce就用reduce。reduce将RDD中元素两两传递给输入函数，同时产生一个新的值，新产生的值与RDD中下一个元素再被传递给输入函数，知道最后有一个值为止。使用指定的交换和关联二进制运算符 reduce RDD的元素。只在本分区本地地进行reduce。123&gt;&gt;&gt; from operator import add&gt;&gt;&gt; sc.parallelize([1, 2, 3, 4, 5]).reduce(add)15 reduceByKey(func, numPartitions = None, parititonFunc = …)使用associative and commutative reduce function融合值。就是按key对值做reduce。与groupByKey不同，会进行一个类似mapreduce中的combine操作。如果未指定numPartitions，则输出将使用numPartition分区进行分区，或默认并行级别。 默认分区器是哈希分区。1234&gt;&gt;&gt; from operator import add&gt;&gt;&gt; rdd = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 1), (&quot;a&quot;, 1)])&gt;&gt;&gt; sorted(rdd.reduceByKey(add).collect())[(&apos;a&apos;, 2), (&apos;b&apos;, 1)] reduceBykey 操作产生一个新的 RDD，其中 key 所有相同的的值组合成为一个 tuple - key 以及与 key 相关联的所有值在 reduce 函数上的执行结果。面临的挑战是，一个 key 的所有值不一定都在一个同一个 paritition 分区里，甚至是不一定在同一台机器里，但是它们必须共同被计算。 在 spark 里，特定的操作需要数据不跨分区分布。在计算期间，一个任务在一个分区上执行，为了所有数据都在单个 reduceByKey 的 reduce 任务上运行，我们需要执行一个 all-to-all 操作。它必须从所有分区读取所有的 key 和 key对应的所有的值，并且跨分区聚集去计算每个 key 的结果 - 这个过程就叫做 shuffle。 尽管每个分区新 shuffle 的数据集将是确定的，分区本身的顺序也是这样，但是这些数据的顺序是不确定的。如果希望 shuffle 后的数据是有序的，可以使用: mapPartitions 对每个 partition 分区进行排序，例如, sorted() repartitionAndSortWithinPartitions 在分区的同时对分区进行高效的排序. sortBy 对 RDD 进行全局的排序 reduceByKeyLocally(func)合并key当中的values用一个关联的reduce函数操作。在 (K, V) pairs 的 dataset 上调用时, 返回 dataset of (K, V) pairs 的 dataset, 其中的 values 是针对每个 key 使用给定的函数 func 来进行聚合的, 它必须是 type (V,V) =&gt; V 的类型. 像 groupByKey 一样, reduce tasks 的数量是可以通过第二个可选的参数来配置的。1234&gt;&gt;&gt; from operator import add&gt;&gt;&gt; rdd = sc.parallelize([(&quot;a&quot;, 1), (&quot;b&quot;, 1), (&quot;a&quot;, 1)])&gt;&gt;&gt; sorted(rdd.reduceByKeyLocally(add).items())[(&apos;a&apos;, 2), (&apos;b&apos;, 1)] treeReduce(f, depth=2)以 multi-level tree 形式 reduce RDD 中的元素。参数：depth ：建议树的深度（默认值：2） 123456789101112&gt;&gt;&gt; add = lambda x, y: x + y&gt;&gt;&gt; rdd = sc.parallelize([-5, -4, -3, -2, -1, 1, 2, 3, 4], 10)&gt;&gt;&gt; rdd.treeReduce(add)-5&gt;&gt;&gt; rdd.treeReduce(add, 1)-5&gt;&gt;&gt; rdd.treeReduce(add, 2)-5&gt;&gt;&gt; rdd.treeReduce(add, 5)-5&gt;&gt;&gt; rdd.treeReduce(add, 10)-5 lookup(key)返回RDD中 key 键对应的值列表。123456789101112&gt;&gt;&gt; l = range(1000)&gt;&gt;&gt; rdd = sc.parallelize(zip(l, l), 10)&gt;&gt;&gt; rdd.lookup(42) # slow[42]&gt;&gt;&gt; sorted = rdd.sortByKey()&gt;&gt;&gt; sorted.lookup(42) # fast[42]&gt;&gt;&gt; sorted.lookup(1024)[]&gt;&gt;&gt; rdd2 = sc.parallelize([((&apos;a&apos;, &apos;b&apos;), &apos;c&apos;)]).groupByKey()&gt;&gt;&gt; list(rdd2.lookup((&apos;a&apos;, &apos;b&apos;))[0])[&apos;c&apos;] first()action函数。返回RDD中的第一个元素，相当于 take(1)123456&gt;&gt;&gt; sc.parallelize([2, 3, 4]).first()2&gt;&gt;&gt; sc.parallelize([]).first()Traceback (most recent call last): ...ValueError: RDD is empty top(num, key = None)得到RDD中最大的 N 个元素。注意：返回到内存中。注意：它返回按降序排列的列表。123456&gt;&gt;&gt; sc.parallelize([10, 4, 2, 12, 3]).top(1)[12]&gt;&gt;&gt; sc.parallelize([2, 3, 4, 5, 6], 2).top(2)[6, 5]&gt;&gt;&gt; sc.parallelize([10, 4, 2, 12, 3]).top(3, key=str)[4, 3, 2] max(key = None)找到此RDD中的最大项目。 参数：key - 用于生成用于比较的键的函数 12345&gt;&gt;&gt; rdd = sc.parallelize([1.0, 5.0, 43.0, 10.0])&gt;&gt;&gt; rdd.max()43.0&gt;&gt;&gt; rdd.max(key=str)5.0 min(key = None)与max类似。找到最小项 take(num)action函数将RDD 中前 num 个元素作为一个数组，返回它首先扫描一个分区，并使用该分区的结果来估计满足限制所需的其他分区数。注意：只有当生成的数组预期为小时，才应使用此方法，因为所有数据都将加载到驱动程序的内存中。123456&gt;&gt;&gt; sc.parallelize([2, 3, 4, 5, 6]).cache().take(2)[2, 3]&gt;&gt;&gt; sc.parallelize([2, 3, 4, 5, 6]).take(10)[2, 3, 4, 5, 6]&gt;&gt;&gt; sc.parallelize(range(100), 100).filter(lambda x: x &gt; 90).take(3)[91, 92, 93] takeOrdered(num, key = None)action函数。返回 RDD 按自然顺序（natural order）或自定义比较器（custom comparator）排序后的前 n 个元素.同样会加载到内存中。1234&gt;&gt;&gt; sc.parallelize([10, 1, 2, 9, 3, 4, 5, 6, 7]).takeOrdered(6)[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; sc.parallelize([10, 1, 2, 9, 3, 4, 5, 6, 7], 2).takeOrdered(6, key=lambda x: -x)[10, 9, 7, 6, 5, 4] takeSample(withReplacement, num, seed=None)action函数。对一个 dataset 进行随机抽样，返回一个包含 num 个随机抽样（random sample）元素的数组，参数 withReplacement 指定是否有放回抽样，参数 seed 指定生成随机数的种子。同样会加载到内存中。1234567&gt;&gt;&gt; rdd = sc.parallelize(range(0, 10))&gt;&gt;&gt; len(rdd.takeSample(True, 20, 1))20&gt;&gt;&gt; len(rdd.takeSample(False, 5, 2))5&gt;&gt;&gt; len(rdd.takeSample(False, 15, 3))10 toLocalIterator()返回一个包含此RDD中所有元素的迭代器。 迭代器将消耗与RDD中最大分区一样多的内存。123&gt;&gt;&gt; rdd = sc.parallelize(range(10))&gt;&gt;&gt; [x for x in rdd.toLocalIterator()][0, 1, 2, 3, 4, 5, 6, 7, 8, 9] id()此RDD的唯一ID（在其SparkContext中）。 setName(name)为此RDD分配名称.123&gt;&gt;&gt; rdd1 = sc.parallelize([1, 2])&gt;&gt;&gt; rdd1.setName(&apos;RDD1&apos;).name()u&apos;RDD1&apos; getNumPartitions()返回RDD中的分区数 123&gt;&gt;&gt; rdd = sc.parallelize([1, 2, 3, 4], 2)&gt;&gt;&gt; rdd.getNumPartitions()2 name()返回RDD名字 isEmpty()当且仅当RDD不包含任何元素时才返回true。 注意，即使RDD至少有1个分区，RDD也可能为空。 1234&gt;&gt;&gt; sc.parallelize([]).isEmpty()True&gt;&gt;&gt; sc.parallelize([1]).isEmpty()False 外部数据集文本文件RDD可以使用SparkContext的textFile方法创建。 该方法为文件（机器上的本地路径或hdfs：//、s3n：//等等）获取URI，并将其作为行的集合读取。 这是一个示例调用：1distFile = sc.textFile(&quot;data.txt&quot;) 一旦创建，distFile可以通过数据集操作来执行。例如，我们可以使用map和reduce操作来加出总所有行的大小，如下所示：1distFile.map(lambda s: len(s)).reduce(lambda a, b: a + b) SparkContext.wholeTextFiles允许您读取包含多个小文本文件的目录，并将它们作为（文件名，内容）对返回。这与textFile相反，textFile将把每个文件的每行作为一个记录返回。 saveAsHadoopDataset(conf, keyConverter = none, valueConverter = None)使用旧的Hadoop OutputFormat API（映射包）将任意一个键值对的RDD（RDD [（K，V）]）输出到任何Hadoop文件系统。 键/值将使用用户指定的转换器转换为输出，或者默认。。。。 saveAsNewAPIHadoopDataset(conf, keyConverter=None, valueConverter=None)saveAsHadoopFile(…)1saveAsHadoopFile(path, outputFormatClass, keyClass=None, valueClass=None, keyConverter=None, valueConverter=None, conf=None, compressionCodecClass=None) saveAsNewAPIHadoopFile(…)1saveAsNewAPIHadoopFile(path, outputFormatClass, keyClass=None, valueClass=None, keyConverter=None, valueConverter=None, conf=None) saveAsPickleFile(path, batchSize=10)将此RDD保存为序列化对象的SequenceFile。 使用的serializer是pyspark.serializers.PickleSerializer，默认批量大小为10。RDD.saveAsPickleFile和SparkContext.pickleFile支持以包含Pickle Python对象的简单格式保存RDD。批次用于酸洗序列化，默认批量大小为10。 123456#tempfile库，创建一个有名字的临时文件&gt;&gt;&gt; tmpFile = NamedTemporaryFile(delete=True)&gt;&gt;&gt; tmpFile.close()&gt;&gt;&gt; sc.parallelize([1, 2, &apos;spark&apos;, &apos;rdd&apos;]).saveAsPickleFile(tmpFile.name, 3)&gt;&gt;&gt; sorted(sc.pickleFile(tmpFile.name, 5).map(str).collect())[&apos;1&apos;, &apos;2&apos;, &apos;rdd&apos;, &apos;spark&apos;] saveAsSequenceFile(path, compressionCodecClass=None)使用从RDD的键和值类型转换的org.apache.hadoop.io.Writable类型，将任何键值对的RDD（RDD [（K，V）]）输出到任何Hadoop文件系统。将 dataset 中的元素以 Hadoop SequenceFile 的形式写入到本地文件系统、HDFS 或其它 Hadoop 支持的文件系统指定的路径中。该操作可以在实现了 Hadoop 的 Writable 接口的键值对（key-value pairs）的 RDD 上使用。在 Scala 中，它还可以隐式转换为 Writable 的类型（Spark 包括了基本类型的转换，例如 Int, Double, String 等等). saveAsTextFile(path, compressionCodecClass=None)action函数将 dataset 中的元素以文本文件（或文本文件集合）的形式写入本地文件系统、HDFS 或其它 Hadoop 支持的文件系统中的给定目录中。Spark 将对每个元素调用 toString 方法，将数据元素转换为文本文件中的一行记录（即使用元素的字符串表示形式）。 1234567&gt;&gt;&gt; tempFile = NamedTemporaryFile(delete=True)&gt;&gt;&gt; tempFile.close()&gt;&gt;&gt; sc.parallelize(range(10)).saveAsTextFile(tempFile.name)&gt;&gt;&gt; from fileinput import input&gt;&gt;&gt; from glob import glob&gt;&gt;&gt; &apos;&apos;.join(sorted(input(glob(tempFile.name + &quot;/part-0000*&quot;))))&apos;0\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n&apos; 保存为文本文件时，可以容忍空行。12345&gt;&gt;&gt; tempFile2 = NamedTemporaryFile(delete=True)&gt;&gt;&gt; tempFile2.close()&gt;&gt;&gt; sc.parallelize([&apos;&apos;, &apos;foo&apos;, &apos;&apos;, &apos;bar&apos;, &apos;&apos;]).saveAsTextFile(tempFile2.name)&gt;&gt;&gt; &apos;&apos;.join(sorted(input(glob(tempFile2.name + &quot;/part-0000*&quot;))))&apos;\\n\\n\\nbar\\nfoo\\n&apos; 外部传递函数给sparkSpark的API很大程度上依赖于驱动程序中的传递函数来在集群上运行。 推荐的方法有三种： Lambda表达式，用于可以写为表达式的简单函数。 （Lambdas不支持多语句函数或不返回值的语句。） 本地def内部的函数调用到Spark，更长的代码。 模块中的Top-level functions。 例如，要传递比使用lambda支持的更长的函数，请考虑以下代码：12345678&quot;&quot;&quot;MyScript.py&quot;&quot;&quot;if __name__ == &quot;__main__&quot;: def myFunc(s): words = s.split(&quot; &quot;) return len(words) sc = SparkContext(...) sc.textFile(&quot;file.txt&quot;).map(myFunc) 请注意，虽然也可以传递对类实例（而不是单例对象）中的方法的引用，但这需要发送包含该类的对象以及该方法。 例如，考虑：12345class MyClass(object): def func(self, s): return s def doStuff(self, rdd): return rdd.map(self.func) 在这里，如果我们创建一个新的MyClass并在其上调用doStuff，那么里面的map会引用MyClass实例的func方法，所以整个对象需要发送到集群。 以类似的方式，访问外部对象的字段将引用整个对象：12345class MyClass(object): def __init__(self): self.field = &quot;Hello&quot; def doStuff(self, rdd): return rdd.map(lambda s: self.field + s) 为了避免这个问题，最简单的方法是将字段复制到局部变量中，而不是外部访问它。123def doStuff(self, rdd): field = self.field return rdd.map(lambda s: field + s) 理解闭包在集群中执行代码时，一个关于 Spark 更难的事情是理解变量和方法的范围和生命周期。不能像以下这样写：12345678910counter = 0rdd = sc.parallelize(data)# Wrong: Don&apos;t do this!!def increment_counter(x): global counter counter += xrdd.foreach(increment_counter)print(&quot;Counter value: &quot;, counter) 上面的代码行为是不确定的，并且可能无法按预期正常工作。执行作业时，Spark 会分解 RDD 操作到每个 executor 中的 task 里。在执行之前，Spark 计算任务的 closure（闭包）。而闭包是在 RDD 上的 executor 必须能够访问的变量和方法（在此情况下的 foreach()）。闭包被序列化并被发送到每个执行器。 闭包的变量副本发给每个 counter ，当 counter 被 foreach 函数引用的时候，它已经不再是 driver node 的 counter 了。虽然在 driver node 仍然有一个 counter 在内存中，但是对 executors 已经不可见。executor 看到的只是序列化的闭包一个副本。所以 counter 最终的值还是 0，因为对 counter 所有的操作均引用序列化的 closure 内的值。 应该使用累加器 类似地，另一种常见的语法用于打印 RDD 的所有元素使用rdd.foreach(println)或 rdd.map(println)。在一台机器上，这将产生预期的输出和打印 RDD 的所有元素。然而，在集群 cluster 模式下，stdout 输出正在被执行写操作 executors 的 stdout 代替，而不是在一个驱动程序上，因此 stdout 的 driver 程序不会显示这些！要打印 driver 程序的所有元素，可以使用的 collect() 方法首先把 RDD 放到 driver 程序节点上: rdd.collect().foreach(println)。这可能会导致 driver 程序耗尽内存，虽说，因为 collect() 获取整个 RDD 到一台机器; 如果你只需要打印 RDD 的几个元素，一个更安全的方法是使用 take(): rdd.take(100).foreach(println)。 键-值对虽然大多数Spark操作适用于包含任何类型对象的RDD，但是几个特殊操作只能在键值对的RDD上使用。 最常见的是分布式“shuffle”操作，例如按键分组或聚合元素。 在Python中，这些操作适用于包含内置Python元组的RDD，例如(1, 2)。 只需创建这样的元组，然后调用所需的操作。 例如，以下代码使用键值对上的reduceByKey操作来计算每行文本在文件中的发生次数： 123lines = sc.textFile(&quot;data.txt&quot;)pairs = lines.map(lambda s: (s, 1))counts = pairs.reduceByKey(lambda a, b: a + b) 例如，我们也可以使用counts.sortByKey()来按字母顺序排列对，最后将counts.collect()作为对象的列表返回到驱动程序。 Shuffle操作Spark 里的某些操作会触发 shuffle。shuffle 是spark 重新分配数据的一种机制，使得这些数据可以跨不同的区域进行分组。这通常涉及在 executors 和 机器之间拷贝数据，这使得 shuffle 成为一个复杂的、代价高的操作。 触发的 shuffle 操作包括 repartition 操作，如 repartition 和 coalesce, ‘ByKey 操作 (除了 counting 之外) 像 groupByKey 和 reduceByKey, 和 join 操作, 像 cogroup 和 join。 性能影响该 Shuffle 是一个代价比较高的操作，它涉及磁盘 I/O、数据序列化、网络 I/O。为了准备 shuffle 操作的数据，Spark 启动了一系列的任务，map 任务组织数据，reduce 完成数据的聚合。这些术语来自 MapReduce，跟 Spark 的 map 操作和 reduce 操作没有关系。 在内部，一个 map 任务的所有结果数据会保存在内存，直到内存不能全部存储为止。然后，这些数据将基于目标分区进行排序并写入一个单独的文件中。在 reduce 时，任务将读取相关的已排序的数据块。 某些 shuffle 操作会大量消耗堆内存空间，因为 shuffle 操作在数据转换前后，需要在使用内存中的数据结构对数据进行组织。需要特别说明的是，reduceByKey 和 aggregateByKey 在 map 时会创建这些数据结构，’ByKey 操作在 reduce 时创建这些数据结构。当内存满的时候，Spark 会把溢出的数据存到磁盘上，这将导致额外的磁盘 I/O 开销和垃圾回收开销的增加。 shuffle 操作还会在磁盘上生成大量的中间文件。在 Spark 1.3 中，这些文件将会保留至对应的 RDD 不在使用并被垃圾回收为止。这么做的好处是，如果在 Spark 重新计算 RDD 的血统关系（lineage）时，shuffle 操作产生的这些中间文件不需要重新创建。如果 Spark 应用长期保持对 RDD 的引用，或者垃圾回收不频繁，这将导致垃圾回收的周期比较长。这意味着，长期运行 Spark 任务可能会消耗大量的磁盘空间。临时数据存储路径可以通过 SparkContext 中设置参数 spark.local.dir 进行配置。 RDD Persistence（持久化）Spark 中一个很重要的能力是将数据 persisting 持久化（或称为 caching 缓存），在多个操作间都可以访问这些持久化的数据。当持久化一个 RDD 时，每个节点的其它分区都可以使用 RDD 在内存中进行计算，在该数据上的其他 action 操作将直接使用内存中的数据。这样会让以后的 action 操作计算速度加快（通常运行速度会加速 10 倍）。缓存是迭代算法和快速的交互式使用的重要工具。 RDD 可以使用 persist() 方法或 cache() 方法进行持久化。数据将会在第一次 action 操作时进行计算，并缓存在节点的内存中。Spark 的缓存具有容错机制，如果一个缓存的 RDD 的某个分区丢失了，Spark 将按照原来的计算过程，自动重新计算并进行缓存。 另外，每个持久化的 RDD 可以使用不同的 storage level 存储级别进行缓存，例如，持久化到磁盘、已序列化的 Java 对象形式持久化到内存（可以节省空间）、跨节点间复制、以 off-heap 的方式存储在 Tachyon。这些存储级别通过传递一个 StorageLevel 对象 (Scala, Java, Python) 给 persist() 方法进行设置。cache() 方法是使用默认存储级别的快捷设置方法，默认的存储级别是 StorageLevel.MEMORY_ONLY（将反序列化的对象存储到内存中）。 存储级别还是看文档 在 Python 中, stored objects will 总是使用 Pickle library 来序列化对象, 所以无论你选择序列化级别都没关系. 在 Python 中可用的存储级别有 MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2, DISK_ONLY, 和 DISK_ONLY_2. 在 shuffle 操作中（例如 reduceByKey），即便是用户没有调用 persist 方法，Spark 也会自动缓存部分中间数据.这么做的目的是，在 shuffle 的过程中某个节点运行失败时，不需要重新计算所有的输入数据。如果用户想多次使用某个 RDD，强烈推荐在该 RDD 上调用 persist() 方法。 如何选择存储级别Spark 的存储级别的选择，核心问题是在 memory 内存使用率和 CPU 效率之间进行权衡。建议按下面的过程进行存储级别的选择：如果您的 RDD 适合于默认存储级别 (MEMORY_ONLY), leave them that way. 这是CPU效率最高的选项，允许RDD上的操作尽可能快地运行. 如果不是, 试着使用 MEMORY_ONLY_SER 和 selecting a fast serialization library 以使对象更加节省空间，但仍然能够快速访问。 (Java和Scala) 不要溢出到磁盘，除非计算您的数据集的函数是昂贵的, 或者它们过滤大量的数据. 否则, 重新计算分区可能与从磁盘读取分区一样快. 如果需要快速故障恢复，请使用复制的存储级别 (e.g. 如果使用Spark来服务 来自网络应用程序的请求). All 存储级别通过重新计算丢失的数据来提供完整的容错能力，但复制的数据可让您继续在 RDD 上运行任务，而无需等待重新计算一个丢失的分区. 删除数据Spark 会自动监视每个节点上的缓存使用情况，并使用 least-recently-used（LRU）的方式来丢弃旧数据分区。 如果您想手动删除 RDD 而不是等待它掉出缓存，使用 RDD.unpersist() 方法。 部署应用到集群中该 应用提交指南 描述了如何将应用提交到集群中. 简单的说, 在您将应用打包成一个JAR(针对 Java/Scala) 或者一组 .py 或 .zip 文件 (针对Python), 该 bin/spark-submit 脚本可以让你提交它到任何所支持的 cluster manager 上去. 单元测试Spark 可以友好的使用流行的单元测试框架进行单元测试。在将 master URL 设置为 local 来测试时会简单的创建一个 SparkContext，运行您的操作，然后调用 SparkContext.stop() 将该作业停止。因为 Spark 不支持在同一个程序中并行的运行两个 contexts，所以需要确保使用 finally 块或者测试框架的tearDown方法将 context 停止。 例程Spark程序示例 您可以通过传递 class name 到 Spark 的 spark-submit 脚本以运行 Python 示例：1./bin/spark-submit examples/src/main/python/pi.py pyspark.sql moduleSpark SQL 和 DataFrames里的重要类 pyspark.sql.SparkSession –DataFrame 和 SQL 功能的主要进入点 pyspark.sql.DataFrame –以列命名的分布式数据集合 pyspark.sql.Column –DataFrame中以列表示的数据，也就是一列数据 pyspark.sql.Row –DataFrame中以行表示的数据，也就是一行数据 pyspark.sql.HiveContext –对Apache Hive中存储数据进行访问的主要进入点 pyspark.sql.GroupedData–DataFrame.groupBy() 返回的聚合方法 pyspark.sql.DataFrameNaFunctions –处理丢失数据的方法(null values). pyspark.sql.DataFrameStatFunctions –统计功能的方法 pyspark.sql.functions –DataFrame可用的内置函数列表 pyspark.sql.types –可用的数据类型列表。 pyspark.sql.Window –处理窗口功能（E） Dataset：Spark新的抽象层Spark最原始的抽象基础是RDD（分布式弹性数据集），但是从Spark 2.0 开始，Dataset将成为Spark新的抽象层。所有的Spark开发者将使用Dataset API和Dataframe（Dataset子集）API编写代码，同时RDD API也还是可以用的，不过已降为low-level的API。 Dataframe API 在Spark 1.3时被引入，Dataset是Dataframe的超集。Dataset API和Dataframe API的使用带给Spark更好的性能和灵活性。Spark Streaming也将使用Dataset代替RDD。 Spark Session：Spark 2.0入口在Spark早期版本，spark context是Spark的入口，RDD API通过context API创建。相应地，streaming由StreamingContext创建；SQL由sqlContext创建；hive由HiveContext创建。而到了Spark 2.0，DataSet和Dataframe API由Spark Session创建。 SparkSession包括SQLContext，HiveContext和StreamingContext的功能。Spark session实际起计算的还是Spark context。 class pyspark.sql.SparkSession1class pyspark.sql.SparkSession(sparkContext, jsparkSession=None) 使用Dataset和DataFrame API编程Spark的入门点。 可以使用SparkSession创建DataFrame，将DataFrame注册为表，在表上执行SQL，缓存表和读取拼贴文件。要创建SparkSession，请使用以下构建器模式：1234567from pyspark.sql import SparkSessionspark = SparkSession\\ .builder\\ .master(&quot;local&quot;) \\ .appName(&quot;PythonWordCount&quot;)\\ .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;) \\ .getOrCreate() class pyspark.sql.HiveContext(sparkContext, jhiveContext=None)Spark SQL的一个变体，与存储在Hive中的数据集成在一起。 Hive的配置从类路径中的hive-site.xml读取。 它支持运行SQL和HiveQL命令。 注意在2.0.0中已弃用。 使用SparkSession.builder.enableHiveSupport().getOrCreate()。12345val sparkSession = SparkSession.builder. master(&quot;local&quot;) .appName(&quot;spark session example&quot;) .enableHiveSupport() .getOrCreate() 读数据使用Spark Session读取CSV数据： 12val df = sparkSession.read.option(&quot;header&quot;,&quot;true&quot;). csv(&quot;src/main/resources/sales.csv&quot;) buiderSparkSession的构建器。 appName(name)设置应用程序的名称，这将在Spark Web UI中显示。如果没有设置应用程序名称，将使用随机生成的名称。 config（key = None，value = None，conf = None）设置一个配置选项。 使用此方法设置的选项将自动传播到SparkConf和SparkSession自己的配置。对于现有的SparkConf，使用conf参数。 123&gt;&gt;&gt; from pyspark.conf import SparkConf&gt;&gt;&gt; SparkSession.builder.config(conf=SparkConf())&lt;pyspark.sql.session... 键值对可以省略参数名称12&gt;&gt;&gt; SparkSession.builder.config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;)&lt;pyspark.sql.session... 参数：key–配置属性的键名字符串value–配置属性的值conf–SparkConf的一个实例 enableHiveSupport()支持Hive支持，包括连接到持续的Hive转移，支持Hive serdes和Hive用户定义的功能。 getOrCreate()获取现有的SparkSession，如果没有现有的SparkSession，则根据此构建器中设置的选项创建一个新的SparkSession。此方法首先检查是否有有效的全局默认SparkSession，如果是，则返回一个。 如果没有有效的全局默认SparkSession存在，该方法将创建一个新的SparkSession并将新创建的SparkSession分配为全局默认值。 123&gt;&gt;&gt; s1 = SparkSession.builder.config(&quot;k1&quot;, &quot;v1&quot;).getOrCreate()&gt;&gt;&gt; s1.conf.get(&quot;k1&quot;) == s1.sparkContext.getConf().get(&quot;k1&quot;) == &quot;v1&quot;True 如果返回现有的SparkSession，则此构建器中指定的配置选项将应用于现有的SparkSession。12345&gt;&gt;&gt; s2 = SparkSession.builder.config(&quot;k2&quot;, &quot;v2&quot;).getOrCreate()&gt;&gt;&gt; s1.conf.get(&quot;k1&quot;) == s2.conf.get(&quot;k1&quot;)True&gt;&gt;&gt; s1.conf.get(&quot;k2&quot;) == s2.conf.get(&quot;k2&quot;)True master(master) 设置要连接的Spark主URL，例如“local”在本地运行，“local [4]”；以4个内核在本地运行，或“spark：// master：7077”在Spark独立群集上运行。参数：master–a url for spark master SparkSession.catalog用户可以创建，删除，更改或查询底层数据库，表格，功能等的接口。 SparkSession.confSpark的运行时配置接口。 这是用户可以获取和设置与Spark SQL相关的所有Spark和Hadoop配置的界面。 获取配置值时，默认值为底层SparkContext中设置的值（如果有）。 SparkSession.createDataFrame1SparkSession.createDataFrame(data, schema=None, samplingRatio=None, verifySchema=True) 根据一个RDD或 list ，或 pandas.DataFrame 创建一个DataFrame， 当schema是列名列表（a list of column names）时，每个列的类型将从数据中推断出来。 当schema为None时，它将尝试从数据中推断出schema（列名和类型），它们应该是Row，或者是namedtuple或dict的RDD。 当schema是pyspark.sql.types.DataType或数据类型字符串时，它必须与实际数据匹配，否则将在运行时抛出异常。 如果给定的schema不是pyspark.sql.types.StructType，它将被包装到一个pyspark.sql.types.StructType作为其唯一的字段，并且字段名称将是“值”，每个记录也将被包装成 元组，可以稍后转换成行。 如果需要schema inference，则使用samplingRatio来确定用于schema inference的行的比例。 如果samplingRatio为None，则会使用第一行。（模式推理是一种用于在解析任何XML文档的结构之后推断XSD（XML模式定义）的技术。） 参数 ： data – 任何类型的SQL数据或列表，或pandas.DataFrame表示的RDD（例如，row，tuple，int，boolean等）。 schema –pyspark.sql.types.DataType或数据类型字符串或列名称列表，默认值为None。 数据类型字符串格式等于pyspark.sql.types.DataType.simpleString，除了顶级结构类型可以省略struct &lt;&gt;和原子类型使用typeName()作为其格式，例如。 对于pyspark.sql.types.ByteType使用byte而不是tinyint。 我们也可以使用int作为IntegerType的简称。 samplingRatio –the sample ratio of rows used for inferring verifySchema – verify data types of every row against schema.返回：DataFrame123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&gt;&gt;&gt; l = [(&apos;Alice&apos;, 1)]&gt;&gt;&gt; spark.createDataFrame(l).collect()[Row(_1=u&apos;Alice&apos;, _2=1)]&gt;&gt;&gt; spark.createDataFrame(l, [&apos;name&apos;, &apos;age&apos;]).collect()[Row(name=u&apos;Alice&apos;, age=1)]======&gt;&gt;&gt; d = [&#123;&apos;name&apos;: &apos;Alice&apos;, &apos;age&apos;: 1&#125;]&gt;&gt;&gt; spark.createDataFrame(d).collect()[Row(age=1, name=u&apos;Alice&apos;)]======&gt;&gt;&gt; rdd = sc.parallelize(l)&gt;&gt;&gt; spark.createDataFrame(rdd).collect()[Row(_1=u&apos;Alice&apos;, _2=1)]&gt;&gt;&gt; df = spark.createDataFrame(rdd, [&apos;name&apos;, &apos;age&apos;])&gt;&gt;&gt; df.collect()[Row(name=u&apos;Alice&apos;, age=1)]======&gt;&gt;&gt; from pyspark.sql import Row&gt;&gt;&gt; Person = Row(&apos;name&apos;, &apos;age&apos;)&gt;&gt;&gt; person = rdd.map(lambda r: Person(*r))&gt;&gt;&gt; df2 = spark.createDataFrame(person)&gt;&gt;&gt; df2.collect()[Row(name=u&apos;Alice&apos;, age=1)]======&gt;&gt;&gt; from pyspark.sql import Row&gt;&gt;&gt; Person = Row(&apos;name&apos;, &apos;age&apos;)&gt;&gt;&gt; person = rdd.map(lambda r: Person(*r))&gt;&gt;&gt; df2 = spark.createDataFrame(person)&gt;&gt;&gt; df2.collect()[Row(name=u&apos;Alice&apos;, age=1)]======&gt;&gt;&gt; from pyspark.sql.types import *&gt;&gt;&gt; schema = StructType([... StructField(&quot;name&quot;, StringType(), True),... StructField(&quot;age&quot;, IntegerType(), True)])&gt;&gt;&gt; df3 = spark.createDataFrame(rdd, schema)&gt;&gt;&gt; df3.collect()[Row(name=u&apos;Alice&apos;, age=1)]======&gt;&gt;&gt; spark.createDataFrame(rdd, &quot;a: string, b: int&quot;).collect()[Row(a=u&apos;Alice&apos;, b=1)]&gt;&gt;&gt; rdd = rdd.map(lambda row: row[1])&gt;&gt;&gt; spark.createDataFrame(rdd, &quot;int&quot;).collect()[Row(value=1)]&gt;&gt;&gt; spark.createDataFrame(rdd, &quot;boolean&quot;).collect()Traceback (most recent call last): ...Py4JJavaError: ... SparkSession.newSession()将新的SparkSession返回为new session，具有单独的SQLConf，注册的临时视图和UDF，但共享SparkContext和表缓存。 SparkSession.range(start, end=None, step=1, numPartitions=None)使用单个pyspark.sql.types.LongType列命名为id创建一个DataFrame，其中包含从start到end（独占）的范围内的元素，具有步长值step。 返回：DataFrame12&gt;&gt;&gt; spark.range(1, 7, 2).collect()[Row(id=1), Row(id=3), Row(id=5)] SparkSession.sparkContext返回底层的SparkContext。 SparkSession.read返回一个DataFrameReader，可以用作DataFrame中的数据读取。 返回：DataFrameReader SparkSession.sql（sqlQuery）返回表示给定查询结果的DataFrame。 返回：DataFrame SparkSession.stop()Stop the underlying SparkContext. SparkSession.table(tableName)将指定的表作为DataFrame返回。1234&gt;&gt;&gt; df.createOrReplaceTempView(&quot;table1&quot;)&gt;&gt;&gt; df2 = spark.table(&quot;table1&quot;)&gt;&gt;&gt; sorted(df.collect()) == sorted(df2.collect())True class pyspark.sql.SQLContext(sparkContext, sparkSession=None, jsqlContext=None)在Spark 1.x中使用Spark中的结构化数据（行和列）的入口点。 从Spark 2.0开始，这被SparkSession所取代。 但是，我们正在为此向后兼容。 可以使用SQLContext创建DataFrame，将DataFrame注册为表，在表上执行SQL，缓存表和读取拼贴文件。 class pyspark.sql.HiveContext(sparkContext, jhiveContext=None)Spark SQL的一个变体，与存储在Hive中的数据集成在一起。 Hive的配置从类路径中的hive-site.xml读取。 它支持运行SQL和HiveQL命令。 注意在2.0.0中已弃用。 使用SparkSession.builder.enableHiveSupport().getOrCreate()。 refreshTable(tableName)无效并刷新所有缓存的给定表的元数据。 出于性能原因，Spark SQL或其使用的外部数据源库可能会缓存有关表的某些元数据，例如块的位置。 当这些更改在Spark SQL之外时，用户应该调用此函数来使缓存无效。","categories":[{"name":"spark","slug":"spark","permalink":"https://xiaobingyan.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://xiaobingyan.github.io/tags/spark/"},{"name":"python","slug":"python","permalink":"https://xiaobingyan.github.io/tags/python/"}]}]}